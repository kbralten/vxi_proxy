name: Build Docker image

on:
  push:
    branches: [ main, master, Dockerize ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Restore build cache
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}

      - name: Login to GitHub Container Registry
        if: github.event_name == 'push'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build image (no push)
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Dockerfile
          platforms: linux/amd64,linux/arm64
          push: false
          load: false
          tags: |
            vxi-proxy:gui
            ghcr.io/${{ github.repository_owner }}/vxi-proxy:gui-${{ github.sha }}

      - name: Show built image info
        if: always()
        run: |
          echo "Built image tags: vxi-proxy:gui and ghcr.io/${{ github.repository_owner }}/vxi-proxy:gui-${{ github.sha }}"

      - name: Build test image (local load)
        run: |
          docker build -t vxi-proxy:ci-test .

      - name: Run container with portmapper enabled
        run: |
          docker rm -f vxi-ci || true
          docker run -d --name vxi-ci -e PORTMAPPER_ENABLED=1 vxi-proxy:ci-test
          # Give it a moment to start
          sleep 2

      - name: Probe portmapper GETPORT for VXI-11
        run: |
          docker exec vxi-ci python - <<'PY'
          from xdrlib import Packer, Unpacker
          from pathlib import Path
          import socket, random, sys
          try:
              from vxi_proxy.config import load_config
          except Exception as exc:
              print(f"import error: {exc}")
              sys.exit(1)

          PMAP_PROG=100000; PMAP_VERS=2; PMAPPROC_GETPORT=3
          MSG_CALL=0; AUTH_NULL=0; IPPROTO_TCP=6
          VXI11_DEVICE_CORE = 0x0607AF
          VXI11_DEVICE_ASYNC = 0x0607B0
          VXI11_DEVICE_INTR = 0x0607B1

          def get_expected_port():
              try:
                  cfg = load_config(Path('/app/config.yaml'))
                  return int(getattr(cfg.server, 'port', 0) or 0)
              except Exception as exc:
                  print(f"failed to read config: {exc}")
                  return 0

          def build_getport_call(xid, prog):
              p = Packer()
              p.pack_uint(xid)
              p.pack_uint(MSG_CALL)
              p.pack_uint(2)  # RPC version
              p.pack_uint(PMAP_PROG)
              p.pack_uint(PMAP_VERS)
              p.pack_uint(PMAPPROC_GETPORT)
              # cred/verf: AUTH_NULL
              p.pack_uint(AUTH_NULL); p.pack_uint(0)
              p.pack_uint(AUTH_NULL); p.pack_uint(0)
              # mapping args: prog, vers, prot, port
              p.pack_uint(prog)
              p.pack_uint(1)
              p.pack_uint(IPPROTO_TCP)
              p.pack_uint(0)
              return p.get_buffer()

          def udp_getport(host, port, prog):
              s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
              s.settimeout(2.0)
              xid = random.randint(1, 2**31-1)
              s.sendto(build_getport_call(xid, prog), (host, port))
              data, _ = s.recvfrom(4096)
              up = Unpacker(data)
              rxid = up.unpack_uint()
              _ = up.unpack_uint(); _ = up.unpack_uint()  # reply, accepted
              _ = up.unpack_uint(); ln = up.unpack_uint(); up.unpack_fopaque(ln)
              _ = up.unpack_uint()  # acceptstat
              port = up.unpack_uint()
              return port

            expected = get_expected_port()
            # CORE should return configured port
            got = udp_getport('127.0.0.1', 111, VXI11_DEVICE_CORE)
            print(f'UDP CORE GETPORT returned {got}, expected {expected}')
            if expected == 0 or got != expected:
              sys.exit(1)
            # ASYNC should also return configured port
            got = udp_getport('127.0.0.1', 111, VXI11_DEVICE_ASYNC)
            print(f'UDP ASYNC GETPORT returned {got}, expected {expected}')
            if got != expected:
              sys.exit(1)
            # INTR should return 0 (unsupported)
            got = udp_getport('127.0.0.1', 111, VXI11_DEVICE_INTR)
            print(f'UDP INTR GETPORT returned {got}, expected 0')
            if got != 0:
              sys.exit(1)
          PY

          - name: Probe portmapper GETPORT over TCP for VXI-11
          run: |
            docker exec vxi-ci python - <<'PY'
            from xdrlib import Packer, Unpacker
            from pathlib import Path
            import socket, random, struct, sys
            try:
              from vxi_proxy.config import load_config
            except Exception as exc:
              print(f"import error: {exc}")
              sys.exit(1)

            PMAP_PROG=100000; PMAP_VERS=2; PMAPPROC_GETPORT=3
            MSG_CALL=0; AUTH_NULL=0; IPPROTO_TCP=6
            VXI11_DEVICE_CORE = 0x0607AF
            VXI11_DEVICE_ASYNC = 0x0607B0
            VXI11_DEVICE_INTR = 0x0607B1

            def get_expected_port():
              try:
                cfg = load_config(Path('/app/config.yaml'))
                return int(getattr(cfg.server, 'port', 0) or 0)
              except Exception as exc:
                print(f"failed to read config: {exc}")
                return 0

            def build_getport_call(xid, prog):
              p = Packer()
              p.pack_uint(xid)
              p.pack_uint(MSG_CALL)
              p.pack_uint(2)  # RPC version
              p.pack_uint(PMAP_PROG)
              p.pack_uint(PMAP_VERS)
              p.pack_uint(PMAPPROC_GETPORT)
              # cred/verf: AUTH_NULL
              p.pack_uint(AUTH_NULL); p.pack_uint(0)
              p.pack_uint(AUTH_NULL); p.pack_uint(0)
              # mapping args: prog, vers, prot, port
              p.pack_uint(prog)
              p.pack_uint(1)
              p.pack_uint(IPPROTO_TCP)
              p.pack_uint(0)
              return p.get_buffer()

            def tcp_getport(host, port, prog):
              s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
              s.settimeout(2.0)
              s.connect((host, port))
              xid = 0x1234ABCD
              payload = build_getport_call(xid, prog)
              rm = 0x80000000 | len(payload)
              s.sendall(struct.pack('!I', rm) + payload)
              # read record marker
              hdr = s.recv(4)
              if len(hdr) < 4:
                return 0
              (rmr,) = struct.unpack('!I', hdr)
              n = rmr & 0x7FFFFFFF
              chunks = []
              to_read = n
              while to_read > 0:
                chunk = s.recv(to_read)
                if not chunk:
                  break
                chunks.append(chunk)
                to_read -= len(chunk)
              data = b''.join(chunks)
              up = Unpacker(data)
              rxid = up.unpack_uint()
              _ = up.unpack_uint(); _ = up.unpack_uint()  # reply, accepted
              _ = up.unpack_uint(); ln = up.unpack_uint(); up.unpack_fopaque(ln)
              _ = up.unpack_uint()  # acceptstat
              port = up.unpack_uint()
              return port

              expected = get_expected_port()
              # CORE should return configured port
              got = tcp_getport('127.0.0.1', 111, VXI11_DEVICE_CORE)
              print(f'TCP CORE GETPORT returned {got}, expected {expected}')
              if expected == 0 or got != expected:
                sys.exit(1)
              # ASYNC should also return configured port
              got = tcp_getport('127.0.0.1', 111, VXI11_DEVICE_ASYNC)
              print(f'TCP ASYNC GETPORT returned {got}, expected {expected}')
              if got != expected:
                sys.exit(1)
              # INTR should return 0 (unsupported)
              got = tcp_getport('127.0.0.1', 111, VXI11_DEVICE_INTR)
              print(f'TCP INTR GETPORT returned {got}, expected 0')
              if got != 0:
                sys.exit(1)
            PY

      - name: Container logs (on failure)
        if: failure()
        run: |
          docker logs vxi-ci || true

      - name: Cleanup container
        if: always()
        run: |
          docker rm -f vxi-ci || true
